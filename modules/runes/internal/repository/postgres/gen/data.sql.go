// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: data.sql

package gen

import (
	"context"
)

const getBalancesAtBlock = `-- name: GetBalancesAtBlock :many
SELECT DISTINCT ON (rune_id) pkscript, block_height, rune_id, value FROM runes_balances WHERE pkscript = $1 AND block_height <= $2 ORDER BY block_height DESC
`

type GetBalancesAtBlockParams struct {
	Pkscript    string
	BlockHeight int32
}

func (q *Queries) GetBalancesAtBlock(ctx context.Context, arg GetBalancesAtBlockParams) ([]RunesBalance, error) {
	rows, err := q.db.Query(ctx, getBalancesAtBlock, arg.Pkscript, arg.BlockHeight)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RunesBalance
	for rows.Next() {
		var i RunesBalance
		if err := rows.Scan(
			&i.Pkscript,
			&i.BlockHeight,
			&i.RuneID,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutPointBalances = `-- name: GetOutPointBalances :many
SELECT rune_id, tx_hash, tx_idx, value FROM runes_outpoint_balances WHERE rune_id = $1 AND tx_hash = $2 AND tx_idx = $3
`

type GetOutPointBalancesParams struct {
	RuneID string
	TxHash string
	TxIdx  int32
}

func (q *Queries) GetOutPointBalances(ctx context.Context, arg GetOutPointBalancesParams) ([]RunesOutpointBalance, error) {
	rows, err := q.db.Query(ctx, getOutPointBalances, arg.RuneID, arg.TxHash, arg.TxIdx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RunesOutpointBalance
	for rows.Next() {
		var i RunesOutpointBalance
		if err := rows.Scan(
			&i.RuneID,
			&i.TxHash,
			&i.TxIdx,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRuneEntriesByRuneIds = `-- name: GetRuneEntriesByRuneIds :many
SELECT rune_id, rune, spacers, burned_amount, mints, premine, symbol, term_amount, term_cap, term_height_start, term_height_end, term_offset_start, term_offset_end, completion_time FROM runes_entries WHERE rune_id = ANY($1::text[])
`

func (q *Queries) GetRuneEntriesByRuneIds(ctx context.Context, runeIds []string) ([]RunesEntry, error) {
	rows, err := q.db.Query(ctx, getRuneEntriesByRuneIds, runeIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RunesEntry
	for rows.Next() {
		var i RunesEntry
		if err := rows.Scan(
			&i.RuneID,
			&i.Rune,
			&i.Spacers,
			&i.BurnedAmount,
			&i.Mints,
			&i.Premine,
			&i.Symbol,
			&i.TermAmount,
			&i.TermCap,
			&i.TermHeightStart,
			&i.TermHeightEnd,
			&i.TermOffsetStart,
			&i.TermOffsetEnd,
			&i.CompletionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRuneEntriesByRunes = `-- name: GetRuneEntriesByRunes :many
SELECT rune_id, rune, spacers, burned_amount, mints, premine, symbol, term_amount, term_cap, term_height_start, term_height_end, term_offset_start, term_offset_end, completion_time FROM runes_entries WHERE rune = ANY($1::text[])
`

func (q *Queries) GetRuneEntriesByRunes(ctx context.Context, runeIds []string) ([]RunesEntry, error) {
	rows, err := q.db.Query(ctx, getRuneEntriesByRunes, runeIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RunesEntry
	for rows.Next() {
		var i RunesEntry
		if err := rows.Scan(
			&i.RuneID,
			&i.Rune,
			&i.Spacers,
			&i.BurnedAmount,
			&i.Mints,
			&i.Premine,
			&i.Symbol,
			&i.TermAmount,
			&i.TermCap,
			&i.TermHeightStart,
			&i.TermHeightEnd,
			&i.TermOffsetStart,
			&i.TermOffsetEnd,
			&i.CompletionTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
