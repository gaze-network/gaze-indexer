// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: batch.go

package gen

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const createInscriptionEntries = `-- name: CreateInscriptionEntries :batchexec
INSERT INTO "brc20_inscription_entries" ("id", "number", "sequence_number", "delegate", "metadata", "metaprotocol", "parents", "pointer", "content", "content_encoding", "content_type", "cursed", "cursed_for_brc20", "created_at", "created_at_height") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
`

type CreateInscriptionEntriesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateInscriptionEntriesParams struct {
	Id              string
	Number          int64
	SequenceNumber  int64
	Delegate        pgtype.Text
	Metadata        []byte
	Metaprotocol    pgtype.Text
	Parents         []string
	Pointer         pgtype.Int8
	Content         []byte
	ContentEncoding pgtype.Text
	ContentType     pgtype.Text
	Cursed          bool
	CursedForBrc20  bool
	CreatedAt       pgtype.Timestamp
	CreatedAtHeight int32
}

func (q *Queries) CreateInscriptionEntries(ctx context.Context, arg []CreateInscriptionEntriesParams) *CreateInscriptionEntriesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Id,
			a.Number,
			a.SequenceNumber,
			a.Delegate,
			a.Metadata,
			a.Metaprotocol,
			a.Parents,
			a.Pointer,
			a.Content,
			a.ContentEncoding,
			a.ContentType,
			a.Cursed,
			a.CursedForBrc20,
			a.CreatedAt,
			a.CreatedAtHeight,
		}
		batch.Queue(createInscriptionEntries, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateInscriptionEntriesBatchResults{br, len(arg), false}
}

func (b *CreateInscriptionEntriesBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateInscriptionEntriesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createInscriptionEntryStates = `-- name: CreateInscriptionEntryStates :batchexec
INSERT INTO "brc20_inscription_entry_states" ("id", "block_height", "transfer_count") VALUES ($1, $2, $3)
`

type CreateInscriptionEntryStatesBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateInscriptionEntryStatesParams struct {
	Id            string
	BlockHeight   int32
	TransferCount int32
}

func (q *Queries) CreateInscriptionEntryStates(ctx context.Context, arg []CreateInscriptionEntryStatesParams) *CreateInscriptionEntryStatesBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.Id,
			a.BlockHeight,
			a.TransferCount,
		}
		batch.Queue(createInscriptionEntryStates, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateInscriptionEntryStatesBatchResults{br, len(arg), false}
}

func (b *CreateInscriptionEntryStatesBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateInscriptionEntryStatesBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const createInscriptionTransfers = `-- name: CreateInscriptionTransfers :batchexec
INSERT INTO "brc20_inscription_transfers" ("inscription_id", "block_height", "tx_index", "old_satpoint_tx_hash", "old_satpoint_out_idx", "old_satpoint_offset", "new_satpoint_tx_hash", "new_satpoint_out_idx", "new_satpoint_offset", "new_pkscript", "new_output_value", "sent_as_fee") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type CreateInscriptionTransfersBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type CreateInscriptionTransfersParams struct {
	InscriptionID     string
	BlockHeight       int32
	TxIndex           int32
	OldSatpointTxHash pgtype.Text
	OldSatpointOutIdx pgtype.Int4
	OldSatpointOffset pgtype.Int8
	NewSatpointTxHash pgtype.Text
	NewSatpointOutIdx pgtype.Int4
	NewSatpointOffset pgtype.Int8
	NewPkscript       string
	NewOutputValue    int64
	SentAsFee         bool
}

func (q *Queries) CreateInscriptionTransfers(ctx context.Context, arg []CreateInscriptionTransfersParams) *CreateInscriptionTransfersBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.InscriptionID,
			a.BlockHeight,
			a.TxIndex,
			a.OldSatpointTxHash,
			a.OldSatpointOutIdx,
			a.OldSatpointOffset,
			a.NewSatpointTxHash,
			a.NewSatpointOutIdx,
			a.NewSatpointOffset,
			a.NewPkscript,
			a.NewOutputValue,
			a.SentAsFee,
		}
		batch.Queue(createInscriptionTransfers, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &CreateInscriptionTransfersBatchResults{br, len(arg), false}
}

func (b *CreateInscriptionTransfersBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *CreateInscriptionTransfersBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
